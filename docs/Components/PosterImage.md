# PosterImage - Documentation technique

## Vue d'ensemble

`PosterImage` est un composant r√©utilisable qui affiche les posters de films avec gestion avanc√©e du chargement, optimisations performances et gestion d'erreurs robuste.

## Localisation

```
qml/components/PosterImage.qml
```

## Caract√©ristiques principales

‚úÖ Chargement asynchrone non-bloquant  
‚úÖ Lazy loading optionnel pour optimisation m√©moire  
‚úÖ Animation shimmer pendant le chargement  
‚úÖ Fallback √©l√©gant en cas d'erreur avec retry  
‚úÖ Optimisation retina/HiDPI automatique  
‚úÖ Coins arrondis avec OpacityMask  
‚úÖ Support multi-r√©solution  
‚úÖ Gestion compl√®te des √©tats visuels  

---

## Import et utilisation

### Import

```qml
import "../components" as Components
```

### Utilisation basique

```qml
Components.PosterImage {
    width: dp(100)
    height: dp(150)
    source: "https://image.tmdb.org/t/p/w342/poster.jpg"
}
```

### Utilisation avec lazy loading

```qml
Components.PosterImage {
    width: dp(100)
    height: dp(150)
    source: "https://image.tmdb.org/t/p/w342/poster.jpg"
    enableLazyLoading: true
    isVisible: itemIsInViewport
    visibilityThreshold: dp(50)
}
```

---

## Propri√©t√©s publiques

### Configuration de base

#### `source` (string)
URL du poster √† charger.

**Type** : `string`  
**D√©faut** : `""`  
**Exemple** :
```qml
source: "https://image.tmdb.org/t/p/w342/jRXYjXNq0Cs2TcJjLkki24MLp7u.jpg"
```

#### `fillMode` (enumeration)
Mode de remplissage de l'image.

**Type** : `Image.fillMode` (alias)  
**D√©faut** : `Image.PreserveAspectCrop`  
**Valeurs possibles** :
- `Image.Stretch` : √âtire l'image
- `Image.PreserveAspectFit` : Garde proportions, peut laisser des bandes
- `Image.PreserveAspectCrop` : Garde proportions, coupe les bords
- `Image.Tile` : R√©p√©tition en mosa√Øque

**Exemple** :
```qml
fillMode: Image.PreserveAspectFit
```

#### `asynchronous` (bool)
Active le chargement asynchrone (non-bloquant).

**Type** : `bool`  
**D√©faut** : `true`  
**Recommandation** : Toujours laisser √† `true` pour performance

**Exemple** :
```qml
asynchronous: true  // Recommand√©
```

#### `borderRadius` (real)
Rayon des coins arrondis en density-independent pixels.

**Type** : `real`  
**D√©faut** : `dp(6)`  
**Exemple** :
```qml
borderRadius: dp(8)  // Coins plus arrondis
borderRadius: 0      // Coins carr√©s
```

### Lazy loading

#### `enableLazyLoading` (bool)
Active le syst√®me de lazy loading.

**Type** : `bool`  
**D√©faut** : `false`  
**Usage** : Activer pour optimiser le chargement dans les listes scrollables

**Exemple** :
```qml
enableLazyLoading: true
```

#### `isVisible` (bool)
Indique si l'image est visible dans le viewport (contr√¥l√© par le parent).

**Type** : `bool`  
**D√©faut** : `true`  
**Usage** : Modifi√© automatiquement par le delegate du GridView/ListView

**Exemple** :
```qml
// Dans un delegate de GridView
isVisible: parent.itemVisible
```

#### `visibilityThreshold` (real)
Seuil en pixels avant/apr√®s la zone visible pour pr√©charger l'image.

**Type** : `real`  
**D√©faut** : `dp(50)`  
**Explication** : L'image commence √† charger quand elle est √† cette distance du bord visible

**Exemple** :
```qml
visibilityThreshold: dp(100)  // Pr√©charge 100px avant
```

### Optimisation avanc√©e (rarement modifi√©es)

#### `cache` (bool)
Active le cache Qt pour l'image d√©cod√©e.

**Type** : `bool`  
**D√©faut** : `true` (implicite dans Qt)

#### `smooth` (bool)
Active l'anti-aliasing pour le redimensionnement.

**Type** : `bool`  
**D√©faut** : `true` (implicite dans Qt)

#### `mipmap` (bool)
G√©n√®re des mipmaps pour qualit√© optimale lors du zoom.

**Type** : `bool`  
**D√©faut** : `false`  
**Co√ªt** : +33% m√©moire vid√©o

#### `maxSourceWidth` / `maxSourceHeight` (real)
Limite maximale de r√©solution charg√©e en m√©moire.

**Type** : `real`  
**D√©faut** : `800` / `1200`  
**Usage** : Ajuster selon besoins qualit√©/m√©moire

---

## Propri√©t√©s en lecture seule (√©tats)

### `status` (enumeration)
√âtat du chargement de l'image (alias direct).

**Type** : `Image.Status`  
**Valeurs** :
- `Image.Null` : Pas de source d√©finie
- `Image.Loading` : Chargement en cours
- `Image.Ready` : Image charg√©e avec succ√®s
- `Image.Error` : Erreur de chargement

**Exemple** :
```qml
Text {
    text: {
        switch (posterImage.status) {
            case Image.Loading: return "Chargement..."
            case Image.Ready: return "Pr√™t"
            case Image.Error: return "Erreur"
            default: return "Vide"
        }
    }
}
```

### `progress` (real)
Progression du chargement (0.0 √† 1.0).

**Type** : `real` (0.0-1.0)  
**Usage** : Afficher une barre de progression

**Exemple** :
```qml
ProgressBar {
    value: posterImage.progress
    visible: posterImage.isLoading
}
```

### `isLoading` (bool)
Indique si l'image est en cours de chargement.

**Type** : `bool`  
**Calcul** : `status === Image.Loading`

### `hasError` (bool)
Indique si une erreur est survenue lors du chargement.

**Type** : `bool`  
**Calcul** : `status === Image.Error`

### `isReady` (bool)
Indique si l'image est charg√©e et pr√™te √† l'affichage.

**Type** : `bool`  
**Calcul** : `status === Image.Ready`

### `shouldLoad` (bool)
Propri√©t√© calcul√©e qui d√©termine si l'image doit √™tre charg√©e.

**Type** : `bool`  
**Calcul** : `!enableLazyLoading || isVisible`  
**Usage** : Interne, contr√¥le le chargement effectif

---

## √âtats visuels

Le composant g√®re automatiquement 4 √©tats visuels distincts :

### 1. √âtat : Chargement actif
**Condition** : `isLoading === true && shouldLoad === true`

**Apparence** :
- Placeholder gris clair (#f0f0f0)
- Animation shimmer (bande blanche traversante)
- Ic√¥ne film (üé¨) au centre

**Code** :
```qml
Rectangle {
    id: placeholder
    visible: isLoading || source === "" || (enableLazyLoading && !shouldLoad)
    color: "#f0f0f0"
    
    // Animation shimmer
    Rectangle {
        id: shimmer
        visible: isLoading && shouldLoad
        // ... animation
    }
}
```

### 2. √âtat : En attente lazy loading
**Condition** : `enableLazyLoading === true && shouldLoad === false`

**Apparence** :
- Placeholder gris plus sombre (#e8e8e8)
- Ic√¥ne ≈ìil (üëÅÔ∏è) au centre
- Pas d'animation shimmer
- Emoji üí§ dans le coin

**Diff√©renciation** : Indique visuellement qu'on attend de devenir visible

### 3. √âtat : Image charg√©e
**Condition** : `isReady === true`

**Apparence** :
- Image affich√©e avec coins arrondis
- Remplissage selon `fillMode`
- OpacityMask pour les coins arrondis

**Code** :
```qml
Image {
    id: image
    visible: isReady
    source: posterImage.shouldLoad ? posterImage.source : ""
    
    layer.enabled: true
    layer.effect: OpacityMask {
        maskSource: Rectangle {
            radius: posterImage.borderRadius
        }
    }
}
```

### 4. √âtat : Erreur
**Condition** : `hasError === true`

**Apparence** :
- Rectangle rose p√¢le (#ffebee)
- Bordure rose (#ffcdd2)
- Ic√¥ne triangle d'avertissement (‚ö†Ô∏è)
- Texte "Image indisponible"
- Texte "Toucher pour r√©essayer"

**Interaction** : Tap pour retry

**Code** :
```qml
Rectangle {
    id: errorFallback
    visible: hasError
    color: "#ffebee"
    border.color: "#ffcdd2"
    
    MouseArea {
        onClicked: {
            // Retry logic
            image.source = ""
            image.source = posterImage.source
        }
    }
}
```

---

## Animation shimmer

### Principe
Effet de "brillance" qui traverse l'√©l√©ment pendant le chargement.

### Param√®tres
- **Largeur** : 60% de la largeur du composant
- **Dur√©e** : 1000ms
- **Boucle** : Infinie pendant `isLoading`
- **Mouvement** : De `-shimmer.width * 0.25` √† `placeholder.width`
- **Easing** : Linear (constant)

### Gradient
```qml
Gradient {
    orientation: Gradient.Horizontal
    GradientStop { position: 0.0; color: "transparent" }
    GradientStop { position: 0.2; color: Qt.rgba(1,1,1,0.3) }
    GradientStop { position: 0.4; color: Qt.rgba(1,1,1,0.8) }
    GradientStop { position: 0.5; color: Qt.rgba(1,1,1,1.0) }  // Blanc pur
    GradientStop { position: 0.6; color: Qt.rgba(1,1,1,0.8) }
    GradientStop { position: 0.8; color: Qt.rgba(1,1,1,0.3) }
    GradientStop { position: 1.0; color: "transparent" }
}
```

### Optimisation
- **Blur** : FastBlur radius 4 pour adoucir
- **Visible** : Seulement si `isLoading && shouldLoad`
- **Logs** : Console messages pour debugging

---

## Optimisation m√©moire et performance

### sourceSize intelligent

Le composant limite automatiquement la r√©solution charg√©e :

```qml
sourceSize.width: Math.min(width * 2, 400)   // Max 400px
sourceSize.height: Math.min(height * 2, 600) // Max 600px
```

**Explications** :
- `width * 2` : Support √©crans Retina (2x pixel density)
- Limite √† 400x600px : Balance qualit√©/m√©moire
- Une image 4K (3840x2160) chargerait ~33MB sans `sourceSize`
- Avec `sourceSize`, max ~960KB (400x600 RGBA)

### Chargement asynchrone

```qml
asynchronous: true
```

- Chargement en thread s√©par√©
- UI reste responsive
- Pas de freeze pendant le d√©codage

### Lazy loading

```qml
readonly property bool shouldLoad: !enableLazyLoading || isVisible
source: posterImage.shouldLoad ? posterImage.source : ""
```

- Images hors √©cran ne sont pas charg√©es
- √âconomise bande passante et m√©moire
- Chargement d√©clench√© d√®s entr√©e dans zone visible + threshold

---

## Gestion d'erreurs et retry

### D√©tection d'erreur

Le composant √©coute automatiquement `image.status` :

```qml
onStatusChanged: {
    switch (status) {
        case Image.Error:
            console.log("‚ùå Erreur image:", posterImage.source)
            break
    }
}
```

### Affichage fallback

Rectangle rose avec ic√¥ne, message et instruction.

### M√©canisme retry

```qml
MouseArea {
    anchors.fill: errorFallback
    onClicked: {
        console.log("üîÑ Retry demand√©")
        var originalSource = posterImage.source
        image.source = ""  // Reset
        Qt.callLater(function() {
            image.source = originalSource  // Rechargement
        })
    }
}
```

**Fonctionnement** :
1. Vider la source (`source = ""`)
2. D√©lai avec `Qt.callLater()`
3. R√©assigner la source originale
4. D√©clenche nouveau chargement

---

## Exemples d'utilisation

### Exemple 1 : Usage basique

```qml
import "../components" as Components

AppPage {
    Components.PosterImage {
        width: dp(150)
        height: dp(225)
        anchors.centerIn: parent
        source: "https://image.tmdb.org/t/p/w342/avatar.jpg"
    }
}
```

### Exemple 2 : Dans une grille avec lazy loading

```qml
GridView {
    id: filmGrid
    
    property real viewportTop: contentY
    property real viewportBottom: contentY + height
    
    delegate: Rectangle {
        property bool itemVisible: {
            var top = y
            var bottom = y + height
            return (bottom >= filmGrid.viewportTop - dp(50)) &&
                   (top <= filmGrid.viewportBottom + dp(50))
        }
        
        Components.PosterImage {
            anchors.fill: parent
            source: modelData.poster_url
            enableLazyLoading: true
            isVisible: parent.itemVisible
        }
    }
}
```

### Exemple 3 : Personnalisation compl√®te

```qml
Components.PosterImage {
    width: dp(200)
    height: dp(300)
    source: filmData.posterUrl
    
    // Style
    borderRadius: dp(12)
    fillMode: Image.PreserveAspectFit
    
    // Performance
    enableLazyLoading: true
    isVisible: inViewport
    visibilityThreshold: dp(100)
    
    // Interaction
    MouseArea {
        anchors.fill: parent
        onClicked: console.log("Poster cliqu√©")
    }
}
```

### Exemple 4 : Monitoring des √©tats

```qml
Components.PosterImage {
    id: poster
    source: filmUrl
    
    // Bindings sur √©tats
    onIsLoadingChanged: {
        console.log("Loading:", isLoading)
    }
    
    onIsReadyChanged: {
        if (isReady) {
            console.log("‚úÖ Poster charg√© avec succ√®s")
        }
    }
    
    onHasErrorChanged: {
        if (hasError) {
            console.log("‚ùå Erreur chargement poster")
        }
    }
}

// Affichage conditionnel externe
Text {
    text: poster.isLoading ? "Chargement..." : "Pr√™t"
}
```

---

## Debugging

### Logs console

Le composant g√©n√®re automatiquement des logs :

```
PosterImage initialis√© pour: https://...poster.jpg
‚è≥ Chargement: https://...poster.jpg
üìä Progression: 50% https://...poster.jpg
‚úÖ Image charg√©e: poster.jpg Taille rendu: 100x150 SourceSize: 200x300
```

### Logs shimmer

```
‚ú® Shimmer d√©marr√© pour: https://...poster.jpg - largeur: 60
üõë Shimmer arr√™t√© pour: https://...poster.jpg
```

### D√©sactiver les logs en production

```qml
onStatusChanged: {
    if (Qt.application.arguments.indexOf("--debug") !== -1) {
        // Logs seulement avec flag --debug
        console.log("Status:", status)
    }
}
```

---

## Bonnes pratiques

### ‚úÖ √Ä faire

1. **Toujours d√©finir width et height**
```qml
PosterImage {
    width: dp(100)
    height: dp(150)
}
```

2. **Activer lazy loading dans les listes**
```qml
PosterImage {
    enableLazyLoading: true
    isVisible: itemInViewport
}
```

3. **Utiliser dp() pour dimensions**
```qml
borderRadius: dp(8)  // Adaptatif
```

4. **V√©rifier la source avant utilisation**
```qml
source: modelData ? modelData.poster_url : ""
```

### ‚ùå √Ä √©viter

1. **Ne pas oublier les dimensions**
```qml
// ‚ùå MAUVAIS : Pas de dimensions
PosterImage {
    source: url
}
```

2. **Ne pas charger toutes les images d'un coup**
```qml
// ‚ùå MAUVAIS : Sans lazy loading dans une grande liste
Repeater {
    model: 1000
    PosterImage { source: "..." }  // 1000 images en m√™me temps !
}
```

3. **Ne pas manipuler l'Image interne directement**
```qml
// ‚ùå MAUVAIS
PosterImage {
    id: poster
    Component.onCompleted: {
        poster.image.source = "..."  // image n'est pas expos√©
    }
}
```

---

## D√©pendances

### Imports requis

```qml
import Felgo 4.0
import QtQuick 2.15
import Qt5Compat.GraphicalEffects  // Pour OpacityMask
```

### Composants Felgo utilis√©s

- `AppIcon` : Ic√¥nes (film, eye, exclamationtriangle)
- `AppText` : Textes avec th√®me
- `Theme` : Couleurs et styles

### Effets Qt utilis√©s

- `OpacityMask` : Coins arrondis de l'image
- `FastBlur` : Adoucissement du shimmer
- `DropShadow` : Ombre (optionnel, comment√©)

---

## Performance

### M√©triques

| M√©trique | Valeur | Contexte |
|----------|--------|----------|
| M√©moire par image | ~960KB max | Avec sourceSize 400x600 RGBA |
| Temps chargement | Variable | D√©pend r√©seau et taille source |
| Impact CPU shimmer | ~2-5% | Animation unique par composant |
| Overhead lazy loading | N√©gligeable | Calcul simple boolean |

### Optimisations appliqu√©es

‚úÖ `sourceSize` limite m√©moire  
‚úÖ `asynchronous` non-bloquant  
‚úÖ `cache` √©vite rechargements  
‚úÖ Lazy loading √©conomise r√©seau  
‚úÖ Shimmer d√©sactiv√© hors chargement  
‚úÖ Bindings optimis√©s (readonly)  

---

## R√©f√©rences

- [Architecture g√©n√©rale](../Architecture/overview.md)
- [Composants guidelines](README.md)
- [CataloguePage usage](../Pages/CataloguePage.md)
- [Lazy loading feature](../Features/lazy-loading.md)
